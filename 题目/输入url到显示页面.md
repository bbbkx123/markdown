# 输入url到显示页面
1. 浏览器中输入网址
2. 域名解析（DNS），找到IP服务器
3. 发起TCP连接，HTTP三次握手,发送请求（Request）缓存策略
4. 服务器响应HTTP(Response) 
5. 浏览器下载资源 html css js images等
6. 浏览器解析代码（如果服务器有gzip压缩，浏览器先解压）
7. 浏览器渲染呈现给用户


## DNS
首先从dns缓存查询, 若没有找到则不停的向上一级请求dns服务器

查询方式:
* 递归查询(主机 ===> 本地dns服务器, 要么返回ip, 要么报错无法查询到)
* 迭代查询(本地dns ===> 外网其他dns, 要么返回ip, 要么告诉下一步去哪里查询)

## TCP

### 什么是TCP
控制传输协议

### 三次握手
> 目的: 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误 
 
1. client向server发送请求连接的信息 (server可以判断出client具备发送能力)
2. server收到client的信息, 向client发送确认信息 (client可以判断出server具备发送和接收能力)
3. client收到server的确认信息, 向server回应收到确认信息, 连接建立 (第三次 双方都保证接收和发送能力都没有问题)

### 四次挥手
(先发送请求的为client)
1. client发送一个断开请求(FIN), 并关闭client到server的数据传输
2. server收到请求, 发送一个确认序号(ACK), 确认序号为FIN + 1
3. server发送一个断开请求(FIN), 并关闭server到client的数据传输
4. client收到请求, 发送一个确认序号(ACK), 确认序号为FIN + 1, 与server断开


## 浏览器解析代码
![](./图片/渲染过程.jpg)
1. 解析HTML, 构成DOM树
2. 解析CSS, 构造CSS规则(CSSOM)
3. 将DOM树和CSSOM生成render树
4. 布局render树(Layout/Reflow), 负责各元素尺寸, 位置的计算
5. 绘制render树(Paint), 负责颜色
6. 浏览器将各层的信息发给GPU, GPU将会合成然后显示在屏幕上




# 前端优化
## 回流(Reflow)和重绘(Repaint)
当页面中的元素的结构、尺寸、位置发生改变时，浏览器计算元素的几何信息过程  
**回流一定会触发重绘，而重绘不一定会回流**

### 怎么样会触发回流？
1. 对可见dom(display不为none)的增删改
2. dom位置尺寸变化(transforms除外)
3. 元素的尺寸 边距 填充 边框
4. 页面渲染初始化
5. 浏览器窗口尺寸变化 ->resize
6. 向浏览器请求某些样式信息 offset scroll client width height getComputedStyle()

### 怎么样减少回流？
1. 使用class改变样式， 避免使用style逐一修改
2. 使用文件片段(合并操作)
3. 使用绝对定位，让dom脱离文档流，阻断回流向上层传播
4. 如在js控制dom移动位置可以尝试通过transform替代left、top定位

### 重绘
将元素的几何消息转换为绝对像素供GPU渲染。

## js阻塞

GUI渲染线程在页面发生回流、重绘时才会触发，它与JS引擎线程属于互斥线程：在同一时间内浏览器只能执行其中的一个线程，如果GUI渲染线程和JS引擎线程其中一个被执行，那么另一个线程将被挂起，等到执行的线程执行结束再执行。

由于这个特点，所以我们在写html过程常常会考虑把script放在body的最后，css放在head中，这样浏览器在执行时会先解析css，再解析html，等到页面内容渲染结束即GUI渲染线程结束时再执行js，避免了因为JS引擎线程中断了GUI渲染线程造成页面渲染不连贯、卡顿的现象。


## 按需加载
这种优化主要针对于短时间内需要加载很多资源的情况，如图片列表、视频、首屏渲染等，通过对资源分割多段，再根据用户的环境需求判断优先加载哪段资源，从而减少单点资源大小，增加响应速度。


## 降低dom树的复杂度
降低dom树的复杂度可以加快浏览器对dom的解析、操作、响应速度
